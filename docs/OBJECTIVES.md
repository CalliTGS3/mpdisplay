# Project goals
1) Decouple lvgl from esp-idf
Currently, lv_binding_micropython includes hardware drivers written in C for several display types including ILI9341, ST7789 and GC9A01.  Because each architecture has its own way of interacting with hardware, including DMA and communications protocols, the C drivers included in lv_binding_micropython are architecture-specific.  The ESP32-specific drivers are written based on ESP-IDF version 4.x.  Those drivers will compile for the original ESP32 microcontroller with ESP-IDF 4.x, but will not compile for newer microcontrollers like the ESP32-S3.  Also, Micropython switched to using ESP-IDF 5.x with Micropython version 1.21. Currently, it is impossible to compile unmodified lv_micropython for an ESP32-S3 target because the drivers, not the binding itself, are tied to an outdated version of ESP-IDF.  The ESP32-S3 is a powerful, very popular and readily available platform, so the incompatibilty has a huge impact on the community.

2) Decouple lvgl from display drivers
In the base LVGL, written in C, it is practical to have the C display drivers bundled with the graphics library, or at least that's the way it seams.  As I understand it, version 9 of LVGL (not lv_micropython) will have TFT_eSPI drivers baked in.  I use LVGL under Micropython, not C, so I may be wrong about that.  However, those drivers cannot easily be used with Micropython (at this point) because there is no interface for them in Micropython.  In LVGL for C, the pins numbers connected from the microcontroller to the display are specified in the compiled code.  In Micropython, they need to be assigned at instantiation by the Micropython code.  In C, when you change a pin number, you re-compile the code and reflash it to the device.  In Micropython, a pin change requires editing the .py file, but there are no re-compile or flash steps.  Eventhough C and Micropython can "speak" to each other, they implement many tasks very differently.  For that reason, it makes sense to have drivers that can be used with Micropython developed in parellel with LVGL developement, not bound to each other, slowing down both tasks when incompatibilities arise.

3) Contribute to enabling lv_binding_micropython to be compiled as USER_C_MODULE
In Micropython, external projects written in C can be tied into the main project which requires modifications to Micropython's build system files.  Such is the case for the ESP32 port of lv_binding_micropython.  This becomes difficult to maintain because changes in Micropython have to be merged back in, which can cause errors.  As such, it is common for this type of project to remain a revision (or several) behind the main Micropython project.  Another way an external project may interface with Micropython is via USER_C_MODULES.  This method keeps the two projects seperate, where their codebases aren't intermingled, making it very easy to update either without having to update both.  To compile the external project into Micropython, (oversimplifying a bit) you download the source code for both projects, save them separately, then add a commandline option USER_C_MODULES=path/to/other/project/somefile when running make in order to end up with a Micropyhon binary that includes the other project.  Such is the case for the Unix and RP2 ports of LVGL.  It is mine and many others' hope that LVGL can be developed as a USER_C_MODULE for all LVGL Micropyton ports.  Doing that would mean we could easily change to a newer, or older, version of Micropython at will, without any modifications required by the LVGL developers.  Work has been done to make the ESP32 port compile as a USER_C_MODULE, but the ESP-IDF version incompatibilities mentioned in paragraph 1 stalled that effort.  Removing the dependency on ESP-IDF from the lv_micropython_binding would mean one less hurdle for getting that done.  (There are other hurdles to that effort, namely that the ESP32 with ESP-IDF build system is different than the RP2 and Linux build systems, and that the best example code is lv_micropython, which has the code for lv_binding_micropython intermingled with Micropyton.)

4) Compile display drivers as a USER_C_MODULE.
https://docs.micropython.org/en/latest/develop/cmodules.html
https://micropython-usermod.readthedocs.io/en/latest/index.html
https://github.com/v923z/micropython-usermod
https://github.com/orgs/micropython/discussions/11660
If the goal is to seperate the LVGL code base from the Micropython code base by making LVGL a USER_C_MODULE, and another goal is to seperate drivers from LVGL, where should the drivers "live"?  They could live in Micropython itself, becoming a built-in part just like wifi or bluetooth.  I'm sure there are lots of reasons against that, not least of which is the burden it would put on the Micropython core developers, if they even accepted the project into the core at all, which is unlikely.  To me, the obvious answer is to make it a USER_C_MODULE, too.  Multiple drivers could coexist on the build system, whether that is an individual's laptop or a Docker container in Github Actions.  As a (wannabe) developer, (OK, I'm an IT guy with an electronics and programming hobby, not a developer) I could have the code for a platform-specific / multi-display driver sitting in a folder next to a multi-platform / display-specific driver.  For example, I may have a driver that only works on ESP32, but works with lots of displays, and have another driver that works with most microcontrollers but only a specific family of ePaper displays.  When I switch from one hardware project to another, I just change my make command-line parameters, and I'm using the correct driver.  When a new version of a driver, or Micropython, or LVGL is released, I can update it if I want without affecting the other code bases.  It is important to note that even though the code bases are seperate, that doesn't mean updates are guaranteed compatible.  If the update you just downloaded turns out not to be compatible, just revert back.

5) Create fast, dma-driven display drivers written in C that could be used with any Micropython graphics library, including but not limited to LVGL.
Display drivers can be written in Micropython, and there are many of them out there that work just fine.  However, for some projects that are graphics intensive, those Micropython drivers are likely slower than desired.  Fast microcontrollers and fast display chips help, but they also need software drivers that are fast enough to keep up with them.  C drivers are the answer, with double-buffered drivers being faster than single-buffered, and DMA-enabled, non-blocking being faster than drivers that don't use DMA and/or are blocking.  Most drivers that can be used by LVGL are specifically linked to LVGL.  That is to say, they make assumptions, and function calls, that are specific to LVGL and would break any other graphics library.  There is nothing wrong with that.  However, if we had a mechanism to allow LVGL to use fast drivers that weren't linked to LVGL, our base of developers grows dramatically.  Whether a developer creates a driver that "accidentally" works with LVGL, or they specifically make sure it works with LVGL in addition to their target (or even self-created) graphics library, the more developers making drivers, or improving the drivers that are already out there, the better.  How do you create a driver that accidentally works with LVGL?  LVGL really only requires one thing of a driver:  blit.  Blit is the foundation of most microcontroller display drivers, so it's not that much of an ask.  Everything else can be setup / managed in Micropython bridging the gap between the C driver and LVGL!

6) Implement drivers that use SPI interfaces that are already instantiated.
The way ESP specific drivers are implemented now, they create SPI devices using ESP calls instead of Micropython standard calls.  That is to say, they don't use Micropython's machine.SPI, but instead they take pin numbers and create the spi interface in C code.  That makes it difficult, or impossible, to communicate with other devices on the same bus, such as SD card readers or some SPI interfaced touchscreens unless drivers for those devices are included in the display driver.

7) Enable using displays with bus types other than SPI, including i80, i2C and possibly RGB (dot-clock, parallel) displays.

8) Develop a small, simple API to bridge non-lvgl specific display and touch drivers with LVGL so other librairies such as TFT-eSPI require little modification, if any, to be used with LVGL
Currently, there isn't a standard API for display driver in lvgl for Micropython.  For example, one driver may expect the spi interface to be instantiated and passed to the driver, while another may expect pin numbers only.  Likewise, control signals like backlight and reset may be required as pin numbers only in one driver, while another driver requires the Pin to already be instantiated and defined as outputs.

9) Provide examples for display_driver.py or display_utils.py for how to use non-lvgl specific drivers for both display and touchscreen.  While we're at it, we should try to include other LVGL indevs (input devices) like encoders and keypads.

10) Possibly use Native machine code in .mpy files
https://docs.micropython.org/en/latest/develop/natmod.html
While it is not a primary goal, the possibly exists to implement these drivers in native machine code that may be distributed as .mpy files.  That would facilitate using one precompiled Micropython firmware with no drivers included, then adding the driver as a .mpy file to the user's project files.  Doing this would allow a builder to switch from one display to another without needing a different binary.  Native machine code is architecture-specific such as armv7emdp for Cortex-M7 and xtensawin for ESP32, and not supported on all architectures that Micropython supports.  Native modules are also tied to the version of Micropython they are compiled against.  I'm not sure of the benefits of native machine modules for display drivers, but it is something to consider.
